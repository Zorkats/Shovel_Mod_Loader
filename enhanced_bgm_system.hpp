// enhanced_bgm_system.h - Better BGM detection and management
#pragma once

#include <windows.h>
#include <map>
#include <string>
#include <vector>
#include <fstream>
#include <chrono>
#include <functional>

#include "simple_yaml_parser.hpp"

class BGMSystem {
public:
    struct TrackInfo {
        uint32_t id;
        std::string name;
        std::string composer;
        std::string stage;
        int trackNumber;
        bool isMusic;
        bool isBoss;
        bool isSpecial;
        std::chrono::steady_clock::time_point startTime;
        uint32_t playCount;
    };

    struct PlaybackState {
        uint32_t currentTrackId;
        bool isPlaying;
        bool isPaused;
        float volume;
        std::chrono::steady_clock::time_point startTime;
        std::chrono::milliseconds duration;
    };

private:
    std::map<uint32_t, TrackInfo> m_trackDatabase;
    PlaybackState m_currentState;
    std::vector<uint32_t> m_playHistory;
    std::map<uint32_t, uint32_t> m_trackPlayCounts;
    bool m_discoveryMode;
    std::string m_databasePath;

    // Callbacks
    std::function<void(const TrackInfo&)> m_onTrackStart;
    std::function<void(const TrackInfo&)> m_onTrackStop;

public:
    BGMSystem(const std::string& databasePath = "bgm_database.yaml")
        : m_databasePath(databasePath), m_discoveryMode(false) {
        m_currentState.currentTrackId = 0;
        m_currentState.isPlaying = false;
        m_currentState.isPaused = false;
        m_currentState.volume = 1.0f;
        m_currentState.startTime = std::chrono::steady_clock::now();
        m_currentState.duration = std::chrono::milliseconds(0);
        LoadDatabase();
    }

    void LoadDatabase() {
        // Load from YAML
        auto yamlData = SimpleYAMLParser::LoadBGMDatabase(m_databasePath);

        for (const auto& [id, entry] : yamlData) {
            TrackInfo info;
            info.id = id;
            info.name = entry.name;
            info.composer = entry.composer;
            info.trackNumber = entry.trackNumber;
            info.isMusic = entry.isMusic;
            info.playCount = 0;

            // Categorize tracks
            info.isBoss = (id >= 0x200 && id < 0x300) ||
                         info.name.find("Battle") != std::string::npos ||
                         info.name.find("Boss") != std::string::npos;

            info.isSpecial = (id >= 0x300 && id < 0x400) ||
                            info.name.find("Special") != std::string::npos ||
                            info.name.find("Secret") != std::string::npos;

            // Determine stage from track name or ID
            info.stage = DetermineStage(id, info.name);

            m_trackDatabase[id] = info;
        }

        std::cout << "[BGMSystem] Loaded " << m_trackDatabase.size() << " tracks from database" << std::endl;
    }

    bool IsDiscoveryMode() const { return m_discoveryMode; }

    void SaveDatabase() {
        // Save discovered tracks back to YAML
        std::ofstream file(m_databasePath + ".discovered");

        file << "# Discovered BGM Tracks\n";
        file << "# Generated by BGMSystem discovery mode\n\n";

        for (const auto& [id, info] : m_trackDatabase) {
            if (info.playCount > 0) {
                file << std::hex << "0x" << id << ":\n";
                file << "  name: \"" << info.name << "\"\n";
                file << "  composer: \"" << info.composer << "\"\n";
                file << "  track_number: " << std::dec << info.trackNumber << "\n";
                file << "  is_music: " << (info.isMusic ? "true" : "false") << "\n";
                file << "  play_count: " << info.playCount << "\n";
                file << "  stage: \"" << info.stage << "\"\n";
                file << "\n";
            }
        }
    }

    std::string DetermineStage(uint32_t id, const std::string& name) {
        // Map IDs to stages
        static const std::map<uint32_t, std::string> stageMap = {
            {0x100, "Plains of Passage"},
            {0x102, "Pridemoor Keep"},
            {0x104, "The Lich Yard"},
            {0x106, "Explodatorium"},
            {0x108, "Iron Whale"},
            {0x10A, "Lost City"},
            {0x10C, "Clockwork Tower"},
            {0x10E, "Stranded Ship"},
            {0x110, "Flying Machine"},
            {0x112, "Tower of Fate"},
            {0x400, "Village"},
            {0x401, "Armor Outpost"},
            {0x402, "Hall of Champions"}
        };

        auto it = stageMap.find(id & 0xFFFE); // Check base ID
        if (it != stageMap.end()) {
            return it->second;
        }

        // Try to determine from name
        if (name.find("Plains") != std::string::npos) return "Plains of Passage";
        if (name.find("Pride") != std::string::npos) return "Pridemoor Keep";
        if (name.find("Lich") != std::string::npos) return "The Lich Yard";
        if (name.find("Plague") != std::string::npos) return "Explodatorium";
        if (name.find("Treasure") != std::string::npos) return "Iron Whale";
        if (name.find("Mole") != std::string::npos) return "Lost City";
        if (name.find("Clockwork") != std::string::npos) return "Clockwork Tower";
        if (name.find("Polar") != std::string::npos) return "Stranded Ship";
        if (name.find("Propeller") != std::string::npos) return "Flying Machine";
        if (name.find("Village") != std::string::npos) return "Village";

        return "Unknown";
    }

    void OnSoundPlay(uint32_t soundId) {
        // Check if it's in our database
        auto it = m_trackDatabase.find(soundId);

        if (it != m_trackDatabase.end() && it->second.isMusic) {
            // Known music track
            HandleMusicStart(it->second);
        } else if (m_discoveryMode) {
            // Discovery mode - analyze unknown sounds
            AnalyzeUnknownSound(soundId);
        }

        // Always track for statistics
        m_trackPlayCounts[soundId]++;
    }

    void HandleMusicStart(TrackInfo& info) {
        // Stop previous track if playing
        if (m_currentState.isPlaying && m_currentState.currentTrackId != info.id) {
            auto prevIt = m_trackDatabase.find(m_currentState.currentTrackId);
            if (prevIt != m_trackDatabase.end() && m_onTrackStop) {
                m_onTrackStop(prevIt->second);
            }
        }

        // Start new track
        m_currentState.currentTrackId = info.id;
        m_currentState.isPlaying = true;
        m_currentState.startTime = std::chrono::steady_clock::now();

        info.startTime = m_currentState.startTime;
        info.playCount++;

        m_playHistory.push_back(info.id);
        if (m_playHistory.size() > 100) {
            m_playHistory.erase(m_playHistory.begin());
        }

        if (m_onTrackStart) {
            m_onTrackStart(info);
        }

        std::cout << "[BGMSystem] Started: " << info.name
                  << " (Stage: " << info.stage << ")" << std::endl;
    }

    void AnalyzeUnknownSound(uint32_t soundId) {
        // Heuristics to determine if it's music
        bool likelyMusic = false;
        std::string guessedName = "Unknown Sound";

        // Check ID patterns
        if ((soundId & 0xFF00) == 0x0100) {
            likelyMusic = true;
            guessedName = "Stage Theme";
        } else if ((soundId & 0xFF00) == 0x0200) {
            likelyMusic = true;
            guessedName = "Boss Theme";
        } else if ((soundId & 0xFF00) == 0x0300) {
            likelyMusic = true;
            guessedName = "Special Theme";
        } else if ((soundId & 0xFF00) == 0x0400) {
            likelyMusic = true;
            guessedName = "Location Theme";
        }

        // Check play frequency
        if (m_trackPlayCounts[soundId] <= 3) {
            // Rarely played sounds are often music
            likelyMusic = true;
        }

        if (likelyMusic && m_trackDatabase.find(soundId) == m_trackDatabase.end()) {
            // Add to database as discovered
            TrackInfo info;
            info.id = soundId;
            info.name = guessedName + " (Discovered)";
            info.composer = "Jake Kaufman";
            info.trackNumber = -1;
            info.isMusic = true;
            info.stage = "Unknown";
            info.playCount = 1;

            m_trackDatabase[soundId] = info;

            std::cout << "[BGMSystem] Discovered new music: 0x" << std::hex << soundId
                      << " - " << guessedName << std::dec << std::endl;

            HandleMusicStart(m_trackDatabase[soundId]);
        }
    }

    // Getters
    const TrackInfo* GetCurrentTrack() const {
        if (m_currentState.currentTrackId == 0) return nullptr;
        auto it = m_trackDatabase.find(m_currentState.currentTrackId);
        return (it != m_trackDatabase.end()) ? &it->second : nullptr;
    }

    std::chrono::milliseconds GetCurrentTrackTime() const {
        if (!m_currentState.isPlaying) return std::chrono::milliseconds(0);
        auto now = std::chrono::steady_clock::now();
        return std::chrono::duration_cast<std::chrono::milliseconds>(now - m_currentState.startTime);
    }

    const std::vector<uint32_t>& GetPlayHistory() const { return m_playHistory; }

    void SetDiscoveryMode(bool enable) {
        m_discoveryMode = enable;
        if (!enable) {
            SaveDatabase(); // Save discoveries
        }
    }

    // Callbacks
    void SetOnTrackStart(std::function<void(const TrackInfo&)> callback) {
        m_onTrackStart = callback;
    }

    void SetOnTrackStop(std::function<void(const TrackInfo&)> callback) {
        m_onTrackStop = callback;
    }

    // Statistics
    void PrintStatistics() {
        std::cout << "\n=== BGM STATISTICS ===" << std::endl;
        std::cout << "Total tracks in database: " << m_trackDatabase.size() << std::endl;
        std::cout << "Unique sounds played: " << m_trackPlayCounts.size() << std::endl;

        std::cout << "\nMost played tracks:" << std::endl;
        std::vector<std::pair<uint32_t, uint32_t>> sorted;
        for (const auto& [id, count] : m_trackPlayCounts) {
            sorted.push_back({id, count});
        }

        std::sort(sorted.begin(), sorted.end(),
                  [](const auto& a, const auto& b) { return a.second > b.second; });

        int shown = 0;
        for (const auto& [id, count] : sorted) {
            if (shown++ >= 10) break;

            auto it = m_trackDatabase.find(id);
            if (it != m_trackDatabase.end()) {
                std::cout << "  " << it->second.name << ": " << count << " times" << std::endl;
            } else {
                std::cout << "  Unknown (0x" << std::hex << id << std::dec << "): "
                          << count << " times" << std::endl;
            }
        }
    }
};